# MIT License
#
# Copyright (c) 2021-2022 Konstantin Karandashev
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from pyscf.gto import Mole
import copy

negligible_coord_diff=1.e-8

# Everything related to convenient handling of ab initio data.

# Internal format for processing AOs.
orb_ang_mom={"s" : 0, "p" : 1, "d" : 2, "f" : 3, "g" : 4, "h" : 5, "i" : 6}

class AO:
    def __init__(self, ao_label, atom_id=None):
        if atom_id is None:
            info=ao_label.split()
            ao_type_large=info[-1]
            if len(info) == 3:
                self.atom_id=int(info[0])
            else:
                # Must be one of those weird labels generated by pyscf.tools.molden.load.
                for char_id, char in enumerate(info[0]):
                    if char.isalpha():
                        self.atom_id=int(info[0][:char_id])
                        break
        else:
            self.atom_id=atom_id
            ao_type_large=ao_label
        for char_id, char in enumerate(ao_type_large):
            if char.isalpha():
                self.ao_type=ao_type_large[:char_id+1]
                self.orientation=ao_type_large[char_id+1:]
                self.angular=orb_ang_mom[char]
                break
    def __str__(self):
        return self.__repr__()
    def __repr__(self):
        return ":atom_id:"+str(self.atom_id)+":ao_type:"+self.ao_type+":ang_momentum:"+str(self.angular)+":orientation:"+self.orientation

def potentially_dependent(ao1, ao2):
    return ((ao1.atom_id==ao2.atom_id) and (ao1.ao_type==ao2.ao_type))

def generate_ao_arr(mol):
    return [AO(ao_label) for ao_label in mol.ao_labels()]

# Contains the same data as a pySCF Mean Field (MF) object.
class Pseudo_MF:
    def __init__(self, e_tot=None, mo_coeff=None, mo_occ=None, mo_energy=None):
        self.e_tot=e_tot
        self.mo_coeff=mo_coeff
        self.mo_occ=mo_occ
        self.mo_energy=mo_energy

# Designed to mimic pySCF's Mole object when used in Pipek-Mezey localization.
class Pseudo_Mole:
    def __init__(self, atomtypes, coordinates, ovlp_mat, aos, atom_ao_ranges):
        self.atom=[[atomtype, atomcoords] for atomtype, atomcoords in zip(atomtypes, coordinates)]
        self.ovlp_mat=ovlp_mat
        self._bas=aos
        self.stdout="PseudoStdout"
        self.atom_ao_ranges=atom_ao_ranges
        self.verbose=False
        self.natm=len(self.atom)
    def offset_nr_by_atom(self):
        return [(0, 0, r1, r2) for (r1, r2) in self.atom_ao_ranges]
    def intor_symmetric(self, keyword):
        if keyword != "int1e_ovlp":
            raise Exception("Unimplemented option for Pseudo_Mole class.")
        return self.ovlp_mat
    def intor_cross(self, keyword, mol1, mol2):
        if len(mol1.atom) != len(mol2.atom):
            raise Exception("Called intor_cross of Pseudo_Mole for different molecules")
        for a1, a2 in zip(mol1.atom, mol2.atom):
            if a1[0] != a2[0]:
                raise Exception("Called intor_cross of Pseudo_Mole for different molecules")
            if np.sum(np.abs(a1[1]-a2[1])) > negligible_coord_diff:
                raise Exception("Called intor_cross of Pseudo_Mole for different molecules")
        return self.ovlp_mat
    def has_ecp(self):
        return False
    def copy(self):
        return copy.deepcopy(self)
    def build(self, *args, basis=None):
        pass
