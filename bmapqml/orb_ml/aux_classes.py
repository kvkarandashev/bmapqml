# MIT License
#
# Copyright (c) 2021-2022 Konstantin Karandashev
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from pyscf.gto import Mole
import copy

negligible_coord_diff=1.e-8

# Everything related to convenient handling of ab initio data.

# Internal format for processing AOs.
orb_ang_mom={"s" : 0, "p" : 1, "d" : 2, "f" : 3, "g" : 4, "h" : 5, "i" : 6}

class AO:
    def __init__(self, ao_label, atom_id=None):
        if isinstance(ao_label, tuple):
            self.orientation="unknown"
            self.ao_types="unknown"
            self.atom_id=ao_label[0]
            self.angular=ao_label[1]
            return
        if atom_id is None:
            info=ao_label.split()
            ao_type_large=info[-1]
            if len(info) == 3:
                self.atom_id=int(info[0])
            else:
                # Must be one of those weird labels generated by pyscf.tools.molden.load.
                for char_id, char in enumerate(info[0]):
                    if char.isalpha():
                        self.atom_id=int(info[0][:char_id])
                        break
        else:
            self.atom_id=atom_id
            ao_type_large=ao_label
        for char_id, char in enumerate(ao_type_large):
            if char.isalpha():
                self.ao_type=ao_type_large[:char_id+1]
                self.orientation=ao_type_large[char_id+1:]
                self.angular=orb_ang_mom[char]
                break
    def __str__(self):
        return self.__repr__()
    def __repr__(self):
        return ":atom_id:"+str(self.atom_id)+":ao_type:"+self.ao_type+":ang_momentum:"+str(self.angular)+":orientation:"+self.orientation

def generate_ao_arr(mol):
    ao_labels=mol.ao_labels()
    return [AO(ao_label) for ao_label in mol.ao_labels()]

# Contains the same data as a pySCF Mean Field (MF) object.
class PseudoMF:
    def __init__(self, e_tot=None, mo_coeff=None, mo_occ=None, mo_energy=None):
        self.e_tot=e_tot
        self.mo_coeff=mo_coeff
        self.mo_occ=mo_occ
        self.mo_energy=mo_energy

# Stores data and mimics pySCF's Mole object when used in Pipek-Mezey localization
# or some other instances throughout the orb_ml module.
class PseudoMole:
    def __init__(self, ovlp_mat, atom_ao_ranges, angular_momenta):
        # Relevant data
        self.natm=ovlp_mat.shape[0]
        self.ovlp_mat=ovlp_mat
        self.atom_ao_ranges=atom_ao_ranges
        self.angular_momenta=angular_momenta
        # Irrelevant attributes only there to pass some of pySCF's checks.
        self.verbose=False
        self.stdout="PseudoStdout"
    # The returned tuples are boundary indices of shells (first two entries) and atomic orbitals (second
    # pair of entries) correponding to a given atom. Since shell indices are not used in the localization procedure
    # their value is set arbitrarily.
    def offset_nr_by_atom(self):
        return [(0, 0, r1, r2) for (r1, r2) in self.atom_ao_ranges]
    def aoslice_by_atom(self):
        return self.offset_nr_by_atom()
    def ao_labels(self):
        output=[]
        for atom_id, ao_range in enumerate(self.atom_ao_ranges):
            for ao_id in range(*ao_range):
                output.append((atom_id, self.angular_momenta[ao_id]))
        return output
    # We only know overlap integrals.
    def intor_symmetric(self, keyword):
        if keyword != "int1e_ovlp":
            raise Exception("Unimplemented option for PseudoMole class.")
        return self.ovlp_mat

